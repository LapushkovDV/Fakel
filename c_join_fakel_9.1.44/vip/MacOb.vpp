 /*
 ╔═══════════════════════════════════════════════════════════════════════════╗
 ║                     (c) 1994,97 корпорация ГАЛАКТИКА                      ║
 ║ Проект        : ГАЛАКТИКА                                                 ║
 ║ Система       : ГАЛАКТИКА                                                 ║
 ║ Версия        : 5.84                                                      ║
 ║ Назначение    : Замена КАУ для объединения                                ║
 ║ Ответственный : Михайлов Сергей Константинович (Michailov)                ║
 ║ Параметры     : при подключении обязательно должна быть в випе переменная ║
 ║                 ExistIntableWithNoIndexRecord типа                        ║
 ╚═══════════════════════════════════════════════════════════════════════════╝
*/
#include ChgPar.vih
// отбираються записи по полю FieldFind значения ValueFind
// потом проверяеться нужно ли менять поля Field1 и Field2
#declare UpdateTableTwoFieldFindOnFieldWithValue(Tabl,Field1,Field2,ValueFind,FieldFind,TablString)
  m_tTimeBeg := Cur_Time;
  if (not nextvisual) ObBreak;
  _Loop #Tabl where ((#ValueFind == #Tabl.#FieldFind))
  {
    if (   (#Tabl.#Field1 = SpJoi.cRec)
        or (#Tabl.#Field2 = SpJoi.cRec))
      insertmarker(MyMarker, #Tabl.nRec);
  }
  CountMarker := getmarkercount(MyMarker);
  StartNewVisual(vtDownVisual, vfTimer, 'Обработка таблицы ' + #TablString, CountMarker + 1);
  for (lCycle := 0; lCycle <> CountMarker; lCycle := lCycle + 1)
    if (GetFirst #Tabl where ((GetMarkerMy(MyMarker, lCycle) == #Tabl.nRec)) = tsOk)
    {
      nextvisual;
      if (#Tabl.#Field1 = SpJoi.cRec)
        #Tabl.#Field1 := JoiHead.cRec;
      if (#Tabl.#Field2 = SpJoi.cRec)
        #Tabl.#Field2 := JoiHead.cRec;

      if (update current #Tabl <> tsOk) msgform(#TablString, #Tabl.nRec, 1);
    }
  stopvisual('', 0);
  InsExecTime(SpJoi.cRec,JoiHead.cRec,#TablString, m_tTimeBeg,Cur_Time);
  clearmarker(mymarker);
#end

#Declare CheckInTableFieldWithIndexAndReplaceWithValue(NameTable, NameField, FirstValue, LastValue, NameTableString)
  if (not NextVisual) ObBreak;
  if ((update visual 'Обработка таблицы #NameTable' #NameTable
       where ((#FirstValue == #NameTable.#NameField))
       set #NameTable.#NameField := #LastValue) <> tsOk) MSGForm(#NameTableString, 0, 4);
#End

#Declare CheckInTableFieldWithNoIndexAndReplaceWithValue(NameTable, NameField, FirstValue, LastValue, NameTableString,CountRecordInTable)
  if (not NextVisual) ObBreak;
  if ((update visual 'Обработка таблицы #NameTable' #NameTable
       where ((#FirstValue == #NameTable.#NameField (noindex)))
       set #NameTable.#NameField := #LastValue) <> tsOk) MSGForm(#NameTableString, 0, 4);
#End
// макрос для таблицы с одним изменяемым полем у которого есть индекс
#Declare UpdateTableOneFieldWithIndex(Tabl,Field,TablString)
  m_tTimeBeg := cur_time;
  if (not NextVisual) ObBreak;
  if ((update visual 'Обработка таблицы #Tabl' #Tabl
       where ((SpJoi.cRec == #Tabl.#Field))
       set #Tabl.#Field := JoiHead.cRec) <> tsOk) MSGForm(#TablString, 0, 4);
  InsExecTime(SpJoi.cRec, JoiHead.cRec, #TablString, m_tTimeBeg, cur_time);
#End
// макрос для таблицы с одним изменяемым полем у которого нет индекс
#Declare UpdateTableOneFieldNoIndex(Tabl,Field,TablString)
  m_tTimeBeg := cur_time;
  if (not NextVisual) ObBreak;
  if ((update visual 'Обработка таблицы #Tabl' #Tabl
       where ((SpJoi.cRec == #Tabl.#Field (noindex)))
       set #Tabl.#Field := JoiHead.cRec) <> tsOk) MSGForm(#TablString, 0, 4);
  InsExecTime(SpJoi.cRec, JoiHead.cRec, #TablString, m_tTimeBeg, Cur_Time);
#End
//макрос для таблицы с 4 изменяемыми полями и у которых нет индекса
#Declare UpdateTable4FieldWithNoIndex(Tabl,Field1,Field2,Field3,Field4,TablString, CountRecordInTable)
  m_tTimeBeg := Cur_Time;
if Not(NextVisual) ObBreak;
StartNewVisual(vtDownVisual, vfTimer, 'Обработка таблицы ' + #TablString, #CountRecordInTable);
_Loop #Tabl
{
  NextVisual;
  ExistIntableWithNoIndexRecord := 0;
  if (SpJoi.cRec = #Tabl.#Field1)
  {
    #Tabl.#Field1 := JoiHead.cRec;
    ExistIntableWithNoIndexRecord := 1;
  }
  if (SpJoi.cRec = #Tabl.#Field2)
  {
    #Tabl.#Field2 := JoiHead.cRec;
    ExistIntableWithNoIndexRecord := 1;
  }
  if (SpJoi.cRec = #Tabl.#Field3)
  {
    #Tabl.#Field3 := JoiHead.cRec;
    ExistIntableWithNoIndexRecord := 1;
  }
  if (SpJoi.cRec = #Tabl.#Field4)
  {
    #Tabl.#Field4 := JoiHead.cRec;
    ExistIntableWithNoIndexRecord := 1;
  }
  if (ExistIntableWithNoIndexRecord = 1)
    if (update current #Tabl <> tsOk) { MSGForm(#TablString, #Tabl.nRec, 1); };
}
InsExecTime(SpJoi.cRec,JoiHead.cRec,#TablString, m_tTimeBeg,Cur_Time);
StopVisual('', 0);
#End
//макрос для таблицы с 6 изменяемыми полями и у которых нет индекса
#Declare UpdateTable6FieldWithNoIndex(Tabl,Field1,Field2,Field3,Field4,Field5,Field6,TablString, CountRecordInTable)
m_tTimeBeg := Cur_Time;
if Not(NextVisual) ObBreak;
StartNewVisual(vtDownVisual, vfTimer, 'Обработка таблицы ' + #TablString, #CountRecordInTable);
_Loop #Tabl
{
  NextVisual;
  ExistIntableWithNoIndexRecord := 0;
  if (SpJoi.cRec = #Tabl.#Field1)
  {
    #Tabl.#Field1 := JoiHead.cRec;
    ExistIntableWithNoIndexRecord := 1;
  }
  if (SpJoi.cRec = #Tabl.#Field2)
  {
    #Tabl.#Field2 := JoiHead.cRec;
    ExistIntableWithNoIndexRecord := 1;
  }
  if (SpJoi.cRec = #Tabl.#Field3)
  {
    #Tabl.#Field3 := JoiHead.cRec;
    ExistIntableWithNoIndexRecord := 1;
  }
  if (SpJoi.cRec = #Tabl.#Field4)
  {
    #Tabl.#Field4 := JoiHead.cRec;
    ExistIntableWithNoIndexRecord := 1;
  }
  if (SpJoi.cRec = #Tabl.#Field5)
  {
    #Tabl.#Field5 := JoiHead.cRec;
    ExistIntableWithNoIndexRecord := 1;
  }
  if (SpJoi.cRec = #Tabl.#Field6)
  {
    #Tabl.#Field6 := JoiHead.cRec;
    ExistIntableWithNoIndexRecord := 1;
  }
  if (ExistIntableWithNoIndexRecord = 1)
    if (update current #Tabl <> tsOk) {MSGForm(#TablString, #Tabl.nRec, 1);};
}
InsExecTime(SpJoi.cRec,JoiHead.cRec,#TablString, m_tTimeBeg,Cur_Time);
StopVisual('', 0);
#End
//макрос для таблицы с тремя изменяемыми полями и у которых нет индекса
#Declare UpdateTable3FieldWithNoIndex(Tabl,Field1,Field2,Field3,TablString, CountRecordInTable)
  m_tTimeBeg := Cur_Time;
if Not(NextVisual) ObBreak;
StartNewVisual(vtDownVisual, vfTimer, 'Обработка таблицы ' + #TablString, #CountRecordInTable);
_Loop #Tabl
{
  NextVisual;
  ExistIntableWithNoIndexRecord := 0;
  if (SpJoi.cRec = #Tabl.#Field1)
  {
    #Tabl.#Field1 := JoiHead.cRec;
    ExistIntableWithNoIndexRecord := 1;
  }
  if (SpJoi.cRec = #Tabl.#Field2)
  {
    #Tabl.#Field2 := JoiHead.cRec;
    ExistIntableWithNoIndexRecord := 1;
  }
  if (SpJoi.cRec = #Tabl.#Field3)
  {
    #Tabl.#Field3 := JoiHead.cRec;
    ExistIntableWithNoIndexRecord := 1;
  }
  if (ExistIntableWithNoIndexRecord = 1)
    if (update current #Tabl <> tsOk) { MSGForm(#TablString, #Tabl.nRec, 1); };
}
InsExecTime(SpJoi.cRec,JoiHead.cRec,#TablString, m_tTimeBeg,Cur_Time);
StopVisual('', 0);
#End
//макрос для таблицы с двумя изменяемыми полями и у которых нет индекса
#Declare UpdateTable2FieldWithNoIndex(Tabl,Field1,Field2,TablString, CountRecordInTable)
m_tTimeBeg := Cur_Time;
if Not(NextVisual) ObBreak;
StartNewVisual(vtDownVisual, vfTimer, 'Обработка таблицы ' + #TablString, #CountRecordInTable);
_Loop #Tabl
{
  NextVisual;
  ExistIntableWithNoIndexRecord := 0;
  if (SpJoi.cRec = #Tabl.#Field1)
  {
    #Tabl.#Field1 := JoiHead.cRec;
    ExistIntableWithNoIndexRecord := 1;
  }
  if (SpJoi.cRec = #Tabl.#Field2)
  {
    #Tabl.#Field2 := JoiHead.cRec;
    ExistIntableWithNoIndexRecord := 1;
  }
  if (ExistIntableWithNoIndexRecord = 1)
    if (update current #Tabl <> tsOk) { MSGForm(#TablString, #Tabl.nRec, 1); };
}
InsExecTime(SpJoi.cRec,JoiHead.cRec,#TablString, m_tTimeBeg,Cur_Time);
StopVisual('', 0);
#End

#Declare UpdateTableOneFieldFindOnTwoFields(Tabl,NameField1,NameField2,ConstForSecondField, TablString,CountRecordInTable)
m_tTimeBeg := Cur_Time;
if Not(NextVisual) ObBreak;
if ((update visual 'Обработка таблицы #Tabl' #Tabl
       where ((SpJoi.cRec == #Tabl.#NameField1(noindex) and #ConstForSecondField == #Tabl.#NameField2(noindex)))
       set #Tabl.#NameField1 := JoiHead.cRec) <> tsOk) MSGForm(#TablString, 0, 4);
InsExecTime(SpJoi.cRec,JoiHead.cRec,#TablString, m_tTimeBeg,Cur_Time);
#End

#Declare UpdateTableOneFieldFindOnTwoFieldsAtlNrec(Tabl,NameField1,NameField2,ConstForSecondField, TablString,CountRecordInTable)
m_tTimeBeg := Cur_Time;
if Not(NextVisual) ObBreak;
if ((update visual 'Обработка таблицы #Tabl' #Tabl
     where ((SpJoi.cRec           == #Tabl.#NameField1 and
             #ConstForSecondField == #Tabl.#NameField2))
       set #Tabl.#NameField1 := JoiHead.cRec) <> tsOk) MSGForm(#TablString, 0, 4);
InsExecTime(SpJoi.cRec,JoiHead.cRec,#TablString, m_tTimeBeg,Cur_Time);
#End
                         //проверил
#Declare UpdateTableOneFieldWithIndexWithOtpEd(Tabl,NameField,NameFieldOtpEd,ValueFieeldOtpEd,TableString)
m_tTimeBeg := Cur_Time;
if Not(NextVisual) ObBreak;
_loop #Tabl where ((SpJoi.cRec == #Tabl.#NameField))
  InsertMarker(MyMarker,#Tabl.nRec);
CountMarker := GetMarkerCount(MyMarker);
StartNewVisual(vtDownVisual,vfTimer,'Обработка таблицы '+#TableString, CountMarker + 1);
For (lCycle:=0; lCycle<>CountMarker; lCycle:=lCycle+1)
  if (GetFirst #Tabl where ((GetMarkerMy(MyMarker,lCycle) == #Tabl.nRec))= tsOk)
  {
    NextVisual;
    #Tabl.#NameField := JoiHead.cRec;
    if ( cOtpEd > 0 )
      #Tabl.#NameFieldOtpEd := #ValueFieeldOtpEd;
    ELSE
      #Tabl.#NameFieldOtpEd := SetOtpEd(#Tabl.#NameFieldOtpEd);
    if (update current #Tabl <> tsOk) MsgForm(#TableString, #Tabl.nRec, 1);
  }
StopVisual('', 0);
InsExecTime(SpJoi.cRec,JoiHead.cRec,#TableString, m_tTimeBeg,Cur_Time);
ClearMarker(MyMarker);
#End

#Declare UpdateTableFieldWithOtpEdNoIndex(Tabl,NameField,NameFieldOtpEd,TableString,CountRecordInTable)
m_tTimeBeg := Cur_Time;
if Not(NextVisual) ObBreak;
StartNewVisual(vtDownVisual,vfTimer,'Обработка таблицы '+#TableString, #CountRecordInTable);
_loop #Tabl
{
  NextVisual;
  if (SpJoi.cRec = #Tabl.#NameField)
  {
    #Tabl.#NameField := JoiHead.cRec;
    if ( cOtpEd > 0 )
      #Tabl.#NameFieldOtpEd := cOtpEd;
    ELSE
      #Tabl.#NameFieldOtpEd := SetOtpEd(#Tabl.#NameFieldOtpEd);
    if (update current #Tabl <> tsOk) MsgForm(#TableString,#Tabl.nRec,1);
  }
}
InsExecTime(SpJoi.cRec,JoiHead.cRec,#TableString, m_tTimeBeg,Cur_Time);
StopVisual('', 0);
#End

#Declare UpdateTableOneFieldWithOtpEdFindOnTwoFieldWithIndex(Tabl,NameField1,NameField2,ConstForSecondField,ValueFieeldOtpEd,TableString)
m_tTimeBeg := Cur_Time;
if Not(NextVisual) ObBreak;
_Loop #Tabl where ((#ConstForSecondField == #Tabl.#NameField2 And
                    SpJoi.cRec           == #Tabl.#NameField1))
  InsertMarker(MyMarker,#Tabl.nRec);
CountMarker := GetMarkerCount(MyMarker);
StartNewVisual(vtDownVisual,vfTimer,'Обработка таблицы '+#TableString, CountMarker + 1);
For (lCycle:=0; lCycle<>CountMarker; lCycle:=lCycle+1)
  if (GetFirst #Tabl where ((GetMarkerMy(MyMarker,lCycle)==#Tabl.nRec))= tsOk)
  {
    NextVisual;
    #Tabl.#NameField1 := JoiHead.cRec;
    if ( cOtpEd > 0 )
      #Tabl.#ValueFieeldOtpEd := cOtpEd;
    ELSE
      #Tabl.#ValueFieeldOtpEd := SetOtpEd(#Tabl.#ValueFieeldOtpEd);
    if (update current #Tabl) <> tsOk then MsgForm(#TableString,#Tabl.nRec,1);
  }
StopVisual('', 0);
InsExecTime(SpJoi.cRec,JoiHead.cRec,#TableString, m_tTimeBeg,Cur_Time);
ClearMarker(MyMarker);
#End

#Declare UpdateTableOneFieldOnTwoFieldWithIndex(Tabl,NameField1,NameField2,ConstForSecondField,TableString)
m_tTimeBeg := cur_time;
if Not(NextVisual) ObBreak;
_Loop #Tabl where ((SpJoi.cRec           == #Tabl.#NameField1 And
                    #ConstForSecondField == #Tabl.#NameField2))
  InsertMarker(MyMarker,#Tabl.nRec);
CountMarker := GetMarkerCount(MyMarker);
StartNewVisual(vtDownVisual,vfTimer,'Обработка таблицы '+#TableString, CountMarker + 1);
For (lCycle:=0; lCycle<>CountMarker; lCycle:=lCycle+1)
  if (GetFirst #Tabl where ((GetMarkerMy(MyMarker,lCycle)==#Tabl.nRec))= tsOk)
  {
    NextVisual;
    #Tabl.#NameField1 := JoiHead.cRec;
    if (update current #Tabl) <> tsOk then MsgForm(#TableString,#Tabl.nRec,1);
  }
StopVisual('', 0);
InsExecTime(SpJoi.cRec,JoiHead.cRec,#TableString, m_tTimeBeg,Cur_Time);
ClearMarker(MyMarker);
#End

#Declare UpdateTableOneFieldOnTwoFieldWithIndex2(Tabl,NameField1,NameField2,ConstForSecondField,TableString)
m_tTimeBeg := cur_time;
if Not(NextVisual) ObBreak;
if ((update visual 'Обработка таблицы #Tabl' #Tabl
     where ((SpJoi.cRec           == #Tabl.#NameField1 and
             #ConstForSecondField == #Tabl.#NameField2))
       set #Tabl.#NameField1 := JoiHead.cRec) <> tsOk) MSGForm(#TableString, 0, 4);
InsExecTime(SpJoi.cRec,JoiHead.cRec,#TableString, m_tTimeBeg,Cur_Time);
#End

#Declare UpdateTableOneFieldOnTwoFieldNoIndex(Tabl,NameField1,NameField2,ConstForSecondField,TableString)
m_tTimeBeg := cur_time;
if (not NextVisual) ObBreak;
if ((update visual 'Обработка таблицы #Tabl' #Tabl
     where ((SpJoi.cRec           == #Tabl.#NameField1 (noindex) and
             #ConstForSecondField == #Tabl.#NameField2 (noindex)))
       set #Tabl.#NameField1 := JoiHead.cRec) <> tsOk) MSGForm(#TableString, 0, 4);
InsExecTime(SpJoi.cRec,JoiHead.cRec,#TableString, m_tTimeBeg,Cur_Time);
#End

#declare DelInTableFieldWithIndex(Tabl,Field,TableString)
m_tTimeBeg := cur_time;
if Not(NextVisual) ObBreak;
_LOOP #Tabl where ((SpJoi.cRec == #Tabl.#Field))
    InsertMarker(MyMarker,#Tabl.nRec);
CountMarker := GetMarkerCount(MyMarker);
StartNewVisual(vtDownVisual,vfTimer,'Обработка таблицы '+#TableString, CountMarker + 1);
For (lCycle:=0; lCycle<>CountMarker; lCycle:=lCycle+1)
  if (GetFirst #Tabl where ((GetMarkerMy(MyMarker,lCycle) == #Tabl.nRec))= tsOk)
  {
    NextVisual;
    if (delete current #Tabl)<>tsOk then MSGForm(#TableString,#Tabl.nRec,2);
  }
StopVisual('', 0);
InsExecTime(SpJoi.cRec,JoiHead.cRec,#TableString, m_tTimeBeg,Cur_Time);
ClearMarker(MyMarker);
#end

#declare DelInTableFieldNoIndex(Tabl,Field,TableString,CountRecordInTable)
m_tTimeBeg := cur_time;
if Not(NextVisual) ObBreak;
StartNewVisual(vtDownVisual,vfTimer,'Обработка таблицы '+#TableString+' (I этап(всего II этапа))', #CountRecordInTable);
_LOOP #Tabl
{
  NextVisual;
  if (SpJoi.cRec = #Tabl.#Field)
    InsertMarker(MyMarker,#Tabl.nRec);
}
StopVisual('', 0);
CountMarker := GetMarkerCount(MyMarker);
StartNewVisual(vtDownVisual,vfTimer,'Обработка таблицы '+#TableString+' (II этап(всего II этапа))', CountMarker + 1);
For (lCycle:=0; lCycle<>CountMarker; lCycle:=lCycle+1)
  if (GetFirst #Tabl where ((GetMarkerMy(MyMarker,lCycle) == #Tabl.nRec))= tsOk)
  {
    NextVisual;
    if (delete current #Tabl)<>tsOk then MSGForm(#TableString,#Tabl.nRec,2);
  }
StopVisual('', 0);
InsExecTime(SpJoi.cRec,JoiHead.cRec,#TableString, m_tTimeBeg,Cur_Time);
ClearMarker(MyMarker);
#end

#declare UpdateTableTwoFieldsEqualAndReplace(Tabl,Field1,Field2,TableString,CountRecordInTable)
if Not(NextVisual) ObBreak;
StartNewVisual(vtDownVisual,vfTimer,'Обработка таблицы '+#TableString+' (I этап(всего II этапа))', #CountRecordInTable);
_LOOP #Tabl
{
  NextVisual;
  if (SpJoi.cRec = #Tabl.#Field1) Or
     (SpJoi.cRec = #Tabl.#Field2)
  {
    if (SpJoi.cRec = #Tabl.#Field1) #Tabl.#Field1 := JoiHead.cRec;
    if (SpJoi.cRec = #Tabl.#Field2) #Tabl.#Field2 := JoiHead.cRec;
    if (update current #Tabl <> tsOk)  MSGForm(#TableString,#Tabl.nRec,1);
  }

}
StopVisual('', 0);
#end

#Declare StartVisualPartOne(TablString,CountRecordInTable)
m_tTimeBeg := Cur_Time;
StartNewVisual(vtDownVisual,vfTimer,'Обработка таблицы '+#TablString+' (I этап(всего II этапа))', #CountRecordInTable);
#End

#Declare StartVisualPartTwo(TablString,CountRecordInTable)
StopVisual('', 0);
StartNewVisual(vtDownVisual,vfTimer,'Обработка таблицы '+#TablString+' (II этап(всего II этапа))', #CountRecordInTable);
#End




#Declare CountRecordInTable(Tabl,Field1,TableString,TableName,FieldName)
StartNewVisual(vtDownVisual,vfTimer,'Обработка таблицы '+#TableString, recordsintable(tn#Tabl));
CountRecord := 0;
_LOOP #Tabl
{
  IError := 1;
  NextVisual;
  if (JoiHead.cRec = #Tabl.#Field1)
    CountRecord := CountRecord + 1;
}
FileProtocol.Writeln('Количество записей в таблице '+ #TableString +' ссылающихся на "'+#TableName.#FieldName+
                     '" равно: '+ string(CountRecord));
StopVisual('',0);
#End

#Declare CountRecordInTableWithTwoField(Tabl,Field1,Field2,ValueField2,TableString,TableName,FieldName)
StartNewVisual(vtDownVisual,vfTimer,'Обработка таблицы '+#TableString, recordsintable(tn#Tabl));
CountRecord := 0;
_LOOP #Tabl
{
  IError := 1;
  NextVisual;
  if (JoiHead.cRec = #Tabl.#Field1)and
     (#Tabl.#Field2 = #ValueField2)
    CountRecord := CountRecord + 1;
}
FileProtocol.Writeln('Количество записей в таблице '+ #TableString +' ссылающихся на "'+#TableName.#FieldName+
                     '" равно: '+ string(CountRecord));
StopVisual('',0);
#End


#Declare CicleCountRecordInTable(Tabl,Field1,TableString,TableName,FieldName)
_Loop SpJoi
{
  CountRecord := 0;
  StartNewVisual(vtDownVisual,vfTimer,'Обработка таблицы '+#TableString, recordsintable(tn#Tabl));
  _LOOP #Tabl
  {
    IError := 1;
    NextVisual;
    if (SpJoi.cRec = #Tabl.#Field1)
      CountRecord := CountRecord + 1;
  }
  FileProtocol.Writeln('  Количество записей в таблице ' + #TableString + ' ссылающихся на "'+#TableName.#FieldName+
                       '" равно: '+ string(CountRecord));

  StopVisual('',0);
}
#End

#Declare CicleCountRecordInTableWithTwoField(Tabl,Field1,Field2,ValueField2,TableString,TableName,FieldName)
_Loop SpJoi
{
  CountRecord := 0;
  StartNewVisual(vtDownVisual,vfTimer,'Обработка таблицы '+#TableString, recordsintable(tn#Tabl));
  _LOOP #Tabl
  {
    IError := 1;
    NextVisual;
    if (SpJoi.cRec = #Tabl.#Field1)and
     (#Tabl.#Field2 = #ValueField2)
      CountRecord := CountRecord + 1;
  }
  FileProtocol.Writeln('  Количество записей в таблице ' + #TableString + ' ссылающихся на "'+#TableName.#FieldName+
                       '" равно: '+ string(CountRecord));
  StopVisual('',0);
}
#End

#Declare CountRecordInTableTune(NameTune)
_Loop Tunedef where ((#NameTune == Tunedef.Code))
{
  StartNewVisual(vtIndicatorVisual, vfTimer,'Обработка таблицы Tuneval', 1);
  CountRecord := 0;
  _LOOP Tuneval where ((    Tunedef.Nrec == TuneVal.cTune))
  {
    IError := 1;
    NextVisual;
    if (JoiHead.cRec = Tuneval.compVal)
      CountRecord := CountRecord + 1;
  }
  FileProtocol.Writeln('Количество записей в таблице Tuneval (настройка ' + gettuneName(#NameTune) + ')ссылающихся на "'+ sObName +
                       '" равно: '+ string(CountRecord));
  StopVisual('',0);
}
#end

#declare CicleCountRecordInTableTune(NameTune)
_Loop SpJoi
{
  CountRecord := 0;
  StartNewVisual(vtIndicatorVisual, vfTimer,'Обработка таблицы Tuneval', 1);
  _Loop Tunedef where ((#NameTune == Tunedef.Code))
  {
    _LOOP Tuneval where ((    Tunedef.Nrec == TuneVal.cTune))
    {
      IError := 1;
      NextVisual;
      if (SpJoi.cRec = Tuneval.compVal)
        CountRecord := CountRecord + 1;
    }
    FileProtocol.Writeln('  Количество записей в таблице Tuneval (настройка ' + gettuneName(#NameTune) + ')ссылающихся на "'+ sOb1Name +
                         '" равно: '+ string(CountRecord));
  }
  StopVisual('',0);
}
#end

#declare UpdateTableTune(NameTune)
{
m_tTimeBeg := Cur_Time;
_Loop Tunedef where ((#NameTune == Tunedef.Code))
{
  if Not(NextVisual) ObBreak;
  StartNewVisual(vtRotateVisual,vfTimer,'Обработка таблицы Tuneval', 0);
  update Tuneval where ((    Tunedef.Nrec == TuneVal.cTune
                         and SpJoi.cRec   == TuneVal.compVal(noindex)))
  set Tuneval.compVal := JoiHead.cRec, Tuneval.strVal := sObName;
  StopVisual('', 0);
}
m_sTitleRep := 'Tuneval with '+#NameTune;
InsExecTime(SpJoi.cRec, JoiHead.cRec, m_sTitleRep, m_tTimeBeg, Cur_Time);
}
#end

#declare InternalFields
  , if (JoiHead.Status = byte(1), 'Начато',
        if (JoiHead.Status = byte(2), 'Прервано',
            if (JoiHead.Status = byte(3), 'Завершено',
                if (JoiHead.Status = byte(4), 'Заверш. с ошиб.', '')))) (fieldname = strJoiStatus)
//----------------------------------------------------------------------------------
  , if (SpJoi.Status = byte(1), 'Начато',
        if (SpJoi.Status = byte(2), 'Прервано',
            if (SpJoi.Status = byte(3), 'Завершено',
                if (SpJoi.Status = byte(4), 'Заверш. с ошиб.', '')))) (fieldname = strSpJoiStatus)
//----------------------------------------------------------------------------------
  , if(SpJoi.IsDel = byte(1), '+', '') (fieldname = cSpJoiDel)
//----------------------------------------------------------------------------------
  , if(JoiHead.prCOrpo <> byte(0), string(JoiHead.prCOrpo),'') (fieldname = strJoiCOrpo)
#end

#declare FindObj(wTypeEvent, TableObj, FieldName, sValueDefault, sMsgObj, cCheckObj, wTypeCase)
  result := false;
  _Loop tmpJoiHead where ((#wTypeEvent == tmpJoiHead.TypeEvent))
  {
    sObjUp := #sValueDefault;
    if (tmpJoiHead.cRec = #cCheckObj)
    {
      result := true;
      if (getFirst #TableObj where ((#cCheckObj == #TableObj.nrec)) = tsOk)
        sObjUp := trim(#TableObj.#FieldName);
      message (#sMsgObj + '"' + sObjUp + '"'
                + chr(13) + if (#wTypeCase = 0, 'уже выбран как результирующий',
                                if (#wTypeCase = 1, 'уже выбрано как результирующее',
                                    'уже выбрана как результирующая')));
      exit;
    }
    sObjDown := #sValueDefault;
    if (getFirst tmpSpJoi where ((    tmpJoiHead.nRec == tmpSpJoi.cJoiHead
                                  and #cCheckObj      == tmpSpJoi.cRec)) = tsOk)
    {
      result := true;
      if ( getFirst #TableObj where ((#cCheckObj == #TableObj.nrec)) = tsOk )
        sObjDown := trim (#TableObj.#FieldName);

      if ( getFirst #TableObj where ((tmpJoiHead.cRec == #TableObj.nrec)) = tsOk )
        sObjUp := trim (#TableObj.#FieldName);
      message (#sMsgObj + '"' + sObjDown + '"'
               + chr(13) + 'уже ' + if (#wTypeCase = 0, 'выбран', if (#wTypeCase = 1, 'выбрано', 'выбрана')) + ' для объединения в' + chr(13) + '"' + sObjUp + '"');
      exit;
    }
  }
#end

#declare protectedcentered
  protect, centered
#end

#declare Check_Obj(TableObj)
  result := False;
  if (GetFirst #TableObj where (( JoiHead.cRec == #TableObj.nRec)) <> tsOk)
    result := True;
#end

#declare Check_Pick(Table)
  //проверяем таблицу, чтобы не выдавалось сообщение два раза при выборе в случае редактирования чужой настройки
  if (curtable <> tn#Table) exit;
  var _sUserName : string = UserName();
  case CurField of
  #JoiHead.UserName :
  {
    if pr_CurUserAdmin
    {
      if JoiHead.UserName <> _sUserName
      {
        if JoiHead.Status =3
        {
          Message('В этом статусе изменять пользователя нельзя');
        }
        else
        {
          if Message('Изменить пользователя на текущего?' , YesNo) = cmYes
          {
            set JoiHead.UserName := _sUserName;
            UpdateTable;
          }
        }
      }
      else
      {
        Message('Объединение уже принадлежит вам');
      }
    }
    else
    {
      Message('Для изменения обратитесь к администратору БД')
    }
    Exit;
  }
  end;
  if (    (JoiHead.UserName <> _sUserName)
      and (JoiHead.cRec <> comp(0)))
  {
    message (lMsgOdebdifferenceUser, Warning);
    exit;
  }
#end

#declare CheckChoiceValueForSpJoiOnPick
  if (m_cChoiceNrec = SpJoi.cRec) exit;// если был объект, и его выбрали опять, то ничего неменяем
  if (FindExistObj(m_cChoiceNrec)) exit;// выдаем предупреждение если уже есть такая настройка
  if (SpJoi.Nrec <> 0)
    if (delete current SpJoi <> tsOk) exit;//удаляем предущую настройку
#end

#declare CheckChoiceValueForJoiHeadOnPick
  if (m_cChoiceNrec = JoiHead.cRec) exit;
  if (FindExistObj(m_cChoiceNrec)) exit;
  if (JoiHead.Nrec <> 0)
  {
     if (GetFirst SpJoi = tsOk)
       delete SpJoi where ((JoiHead.nRec == SpJoi.cJoiHead));
  }
  set JoiHead.cRec := m_cChoiceNrec;
#end
